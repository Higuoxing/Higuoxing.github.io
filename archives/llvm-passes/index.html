<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>LLVM Passes | /dev/urandom</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="shortcut icon" href="/img/favicon.png" type="image/x-icon" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">$Home</a></li>
      
      <li><a href="/archives/">Archives</a></li>
      
      <li><a href="/links/">Links</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">LLVM Passes</span></h1>

<h2 class="date">2018/09/22</h2>
</div>

<main>


<h3 id="introduction">Introduction</h3>

<p>One of the most important parts of a compiler is the optimization system. In LLVM, these works are done by <em>LLVM Pass Framework</em>. LLVM Passes perform various transforms/optimizations over functions, modules and so on. Besides, owing to its perfect modular design, passes could be combined and scheduled to construct successful compilers, like GHC, Swift etc. If you are interested in the ideas behind the LLVM compiler infrastructure, I recommend you going through this article <a href="http://www.aosabook.org/en/llvm.html">LLVM - The Architecture of Open Source Applications</a> by Chris Lattner. This article is my notes on <em>LLVM Passes Framework</em>, mostly are dumped from LLVM websites, see my footnotes.</p>

<h3 id="overview">Overview</h3>

<p>If you are familiar with LLVM IR, you will not surprised that LLVM Passes are divided into several different levels (<em>Module</em>, <em>Function</em>, <em>BasicBlock</em> and <em>Instruction</em>) to handle different types of optimizations or transforms. Usually, a single source file can be treated as a <em>Module</em>, which contained <em>Functions</em>. A <em>Function</em> can has <em>BasicBlocks</em>, which contains <em>Instructions</em>. These abstract structures (except <em>Module</em>), all are <em>Value</em> in LLVM. Besides, <em>Module</em>, <em>Function</em> and <em>BasicBlock</em> are iterable.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">llvm<span style="color:#666">::</span>Module<span style="color:#666">::</span>iterator      <span style="color:#080;font-style:italic">/* iterate to walk Functions inside Module */</span>
llvm<span style="color:#666">::</span>Function<span style="color:#666">::</span>iterator    <span style="color:#080;font-style:italic">/* iterate to walk BasicBlocks inside Function */</span>
llvm<span style="color:#666">::</span>BasicBlock<span style="color:#666">::</span>iterator  <span style="color:#080;font-style:italic">/* iterate to walk Instructions inside BasicBlock */</span>

         <span style="color:#666">*</span>Hierarchy of LLVM<span style="color:#666">-</span>IR<span style="color:#666">*</span>
<span style="color:#666">+------------------------------------------+</span>
<span style="color:#666">|</span> Module                                   <span style="color:#666">|</span>
<span style="color:#666">|</span> <span style="color:#666">+-------------+</span>  <span style="color:#666">+---------------------+</span> <span style="color:#666">|</span>
<span style="color:#666">|</span> <span style="color:#666">|</span> Global Vars <span style="color:#666">|</span>  <span style="color:#666">|</span> Function            <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span> <span style="color:#666">+-------------+</span>  <span style="color:#666">|</span> <span style="color:#666">+-----------------+</span> <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span>                  <span style="color:#666">|</span> <span style="color:#666">|</span> BasicBlock      <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span>                  <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">+-------------+</span> <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span>                  <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">|</span> Instruction <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span>                  <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">+-------------+</span> <span style="color:#666">|</span> <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span>                  <span style="color:#666">|</span> <span style="color:#666">+-----------------+</span> <span style="color:#666">|</span> <span style="color:#666">|</span>
<span style="color:#666">|</span>                  <span style="color:#666">+---------------------+</span> <span style="color:#666">|</span>
<span style="color:#666">+------------------------------------------+</span>
</code></pre></div>
<h3 id="llvm-passes">LLVM Passes</h3>

<p>There are multiple Passes class, <em>ImmutablePass</em>, <em>ModulePass</em>, <em>CallGraphSCCPass</em>, <em>FunctionPass</em>, <em>LoopPass</em>, <em>RegionPass</em>, <em>BasicBlockPass</em> and <em>MachineFunctionPass</em>. They are all inherited from class <em>Pass</em>. So, LLVM Pass Framework will excute our Pass efficiently, depending on the class that our Pass derived from. I will not focus on all these class listed, only give some simple examples.</p>

<h4 id="immutablepass">ImmutablePass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1ImmutablePass.html"><em>ImmutablePass</em></a> is a very special Pass. It provides information about target information, compiler configuration and so on. It just provides some useful information.</p>

<h4 id="modulepass">ModulePass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1ModulePass.html"><em>ModulePass</em></a> treats a single file as a unit. Usually, <em>ModulePass</em> can do some transforms or analyses on the highest level. This could give us a global view on our program.</p>

<p>e.g. Traverse a program and iterate over its <em>Modules</em>, <em>Functions</em>, <em>BasicBlocks</em>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#a0a000">SimpleModulePass</span> : <span style="color:#a2f;font-weight:bold">public</span> ModulePass {
  <span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">char</span> ID;
  SimpleModulePass() <span style="color:#666">:</span> ModulePass(ID) {  }

  <span style="color:#0b0;font-weight:bold">bool</span> runOnModule(Module <span style="color:#666">&amp;</span>M) <span style="color:#a2f;font-weight:bold">override</span> {
    errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;Enter Module: &#34;</span>;
    errs().write_escaped(M.getName()) <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">F</span>: M) {
      errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;Enter Function: &#34;</span>;
      errs().write_escaped(F.getName()) <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
      <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">BB</span>: F) {
        errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;Enter BasicBlock: &#34;</span>;
        errs().write_escaped(BB.getName()) <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
        <span style="color:#080;font-style:italic">/* This will get nothing, because BasicBlock has no name by default */</span>
        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">I</span>: BB) {
          errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;Instruction: &#34;</span>;
          errs() <span style="color:#666">&lt;&lt;</span> I.getOpcodeName() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
        }
      }
    }
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>; <span style="color:#080;font-style:italic">/* We only collect some information */</span>
  }
};
</code></pre></div>
<h4 id="callgraphsccpass">CallGraphSCCPass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1CallGraphSCCPass.html"><em>CallGraphSCCPass</em></a> usually optimize a program by traversing the call graph bottom-up. We could use <code>opt -dot-callgraph</code> command to generate a call graph for whole program.</p>

<p>e.g. Generate a call graph for the codes below</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#080">#include</span> <span style="color:#080">&lt;iostream&gt;</span><span style="color:#080">
</span><span style="color:#080"></span><span style="color:#a2f;font-weight:bold">using</span> <span style="color:#a2f;font-weight:bold">namespace</span> std;

<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">plusOne</span>(<span style="color:#0b0;font-weight:bold">int</span> n) {
  <span style="color:#a2f;font-weight:bold">return</span> n<span style="color:#666">+</span><span style="color:#666">1</span>;
}

<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">plusTwo</span>(<span style="color:#0b0;font-weight:bold">int</span> n) {
  <span style="color:#0b0;font-weight:bold">int</span> n1 <span style="color:#666">=</span> plusOne(n);
  <span style="color:#0b0;font-weight:bold">int</span> n2 <span style="color:#666">=</span> plusOne(n1);
  <span style="color:#a2f;font-weight:bold">return</span> n2;
}

<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">main</span>() {
  <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> <span style="color:#666">1</span>;
  <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> plusTwo(n);
  <span style="color:#0b0;font-weight:bold">int</span> p <span style="color:#666">=</span> plusOne(n);
  printf(<span style="color:#b44">&#34;%d %d %d&#34;</span>, n, m, p);
  <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
}
</code></pre></div>
<p><img src="/archives/llvm-passes/callgraph.png" alt="callgraph" /></p>

<p>Each nodes in a call graph represents a function call, and the edges represents a function call (from its begining to its ending). <em>SCC</em> means &ldquo;Strongly Connected Component&rdquo; (See: <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">Wikipedia</a>).</p>

<p>e.g. Simple <em>CallGraphSCCPass</em> that dumps call graph info</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#a0a000">SimpleCallGraphSCCPass</span>: <span style="color:#a2f;font-weight:bold">public</span> CallGraphSCCPass {
  <span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">char</span> ID;
  SimpleCallGraphSCCPass()<span style="color:#666">:</span> CallGraphSCCPass(ID) {  }

  <span style="color:#0b0;font-weight:bold">bool</span> runOnSCC(CallGraphSCC <span style="color:#666">&amp;</span>SCC) <span style="color:#a2f;font-weight:bold">override</span> {
    errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34; --- Enter Call Graph SCC ---</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>;
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">G</span> : SCC) {
      G<span style="color:#666">-&gt;</span>dump();
    }
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
    errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34; --- end of CallGraphSCC ---</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>;
  }
};
</code></pre></div>
<p>Execite this Pass will get</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"> --- Enter Call Graph SCC ---
Call graph node <span style="color:#a2f;font-weight:bold">for</span> <span style="color:#a2f;font-weight:bold">function</span>: <span style="color:#b44">&#39;_Z7plusOnei&#39;</span><span style="color:#b44">&lt;&lt;0x7fdf04c04160&gt;&gt;  #uses=4
</span><span style="color:#b44">
</span><span style="color:#b44"> --- Enter Call Graph SCC ---
</span><span style="color:#b44">Call graph node for function: &#39;_Z7plusTwoi&#39;&lt;&lt;0x7fdf04c041</span>e0&gt;&gt;  <span style="color:#080;font-style:italic">#uses=2
</span><span style="color:#080;font-style:italic"></span>  CS&lt;0x7fdf04d05790&gt; calls <span style="color:#a2f;font-weight:bold">function</span> <span style="color:#b44">&#39;_Z7plusOnei&#39;</span>
  CS&lt;0x7fdf04d05fa0&gt; calls <span style="color:#a2f;font-weight:bold">function</span> <span style="color:#b44">&#39;_Z7plusOnei&#39;</span>

 --- Enter Call Graph SCC ---
Call graph node <span style="color:#b44">&lt;&lt;null function&gt;&gt;&lt;&lt;0x7fdf04c04100&gt;&gt;  #uses=1
</span><span style="color:#b44">
</span><span style="color:#b44"> --- Enter Call Graph SCC ---
</span><span style="color:#b44">Call graph node for function: &#39;printf&#39;&lt;&lt;0x7fdf04c043a0&gt;&gt;  #uses=2
</span><span style="color:#b44">  CS&lt;0x0&gt; calls external node
</span><span style="color:#b44">
</span><span style="color:#b44"> --- Enter Call Graph SCC ---
</span><span style="color:#b44">Call graph node for function: &#39;main&#39;&lt;&lt;0x7fdf04c042c0&gt;&gt;  #uses=1
</span><span style="color:#b44">  CS&lt;0x7fdf04d06ce0&gt; calls function &#39;_Z7plusTwoi&#39;
</span><span style="color:#b44">  CS&lt;0x7fdf04d06e30&gt; calls function &#39;_Z7plusOnei&#39;
</span><span style="color:#b44">  CS&lt;0x7fdf04d07088&gt; calls function &#39;printf&#39;
</span><span style="color:#b44">
</span><span style="color:#b44"> --- Enter Call Graph SCC ---
</span><span style="color:#b44">Call graph node &lt;&lt;null</span> <span style="color:#a2f;font-weight:bold">function</span>&gt;&gt;<span style="color:#b44">&lt;&lt;0x7fdf04c040d0&gt;&gt;  #uses=0
</span><span style="color:#b44">  CS&lt;0x</span><span style="color:#666">0</span>&gt; calls <span style="color:#a2f;font-weight:bold">function</span> <span style="color:#b44">&#39;_Z7plusOnei&#39;</span>
  CS&lt;0x0&gt; calls <span style="color:#a2f;font-weight:bold">function</span> <span style="color:#b44">&#39;_Z7plusTwoi&#39;</span>
  CS&lt;0x0&gt; calls <span style="color:#a2f;font-weight:bold">function</span> <span style="color:#b44">&#39;main&#39;</span>
  CS&lt;0x0&gt; calls <span style="color:#a2f;font-weight:bold">function</span> <span style="color:#b44">&#39;printf&#39;</span></code></pre></div>
<h4 id="functionpass">FunctionPass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1FunctionPass.html"><em>FunctionPass</em></a> optimized one function at a time. There are two constraints that you might choose <em>FunctionPass</em>:</p>

<ul>
<li>Optimizations are organized globally, i.e., a function at a time</li>
<li>Optimizing a function that does not cause addition or removal of any functions in the module.</li>
</ul>

<p>e.g. Count the number of operators in a program.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#a0a000">OpsCounter</span> : <span style="color:#a2f;font-weight:bold">public</span> FunctionPass {
  <span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">char</span> ID;
  std<span style="color:#666">::</span>map<span style="color:#666">&lt;</span>std<span style="color:#666">::</span>string, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> opCounter;
  OpsCounter()<span style="color:#666">:</span> FunctionPass(ID) {  }

  <span style="color:#0b0;font-weight:bold">bool</span> runOnFunction(Function <span style="color:#666">&amp;</span>F) <span style="color:#a2f;font-weight:bold">override</span> {
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">BB</span> : F) {
      <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">I</span> : BB) {
        <span style="color:#a2f;font-weight:bold">auto</span> opcode_it <span style="color:#666">=</span> opCounter.find(I.getOpcodeName());
        <span style="color:#a2f;font-weight:bold">if</span> (opcode_it <span style="color:#666">!=</span> opCounter.end())
          <span style="color:#080;font-style:italic">// find one
</span><span style="color:#080;font-style:italic"></span>          <span style="color:#666">++</span> opCounter[I.getOpcodeName()];
        <span style="color:#a2f;font-weight:bold">else</span>
          opCounter[I.getOpcodeName()] <span style="color:#666">=</span> <span style="color:#666">1</span>;
      }
    }
    errs() <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;opcode&#34;</span> <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\t&#39;</span> <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;count&#34;</span> <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">op</span> : opCounter)
      errs() <span style="color:#666">&lt;&lt;</span> op.first <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\t&#39;</span> <span style="color:#666">&lt;&lt;</span> op.second <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
  }
};
</code></pre></div>
<h4 id="basicblockpass">BasicBlockPass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1BasicBlockPass.html"><em>BasicBlockPass</em></a> is used to implement local optimizations. It will visit each basic block in each function. LLVM Doc gives 3 constraints that if our codes meet, we should use it.</p>

<ul>
<li>Optimizations are local, operating on either a basic block or instruction at a time.</li>
<li>Optimizations do not modify the CFG of the contained function, or any other basic block in the function.</li>
<li>Optimizations conform to all of the constraints of FunctionPasses.</li>
</ul>

<p>The basic usage of <em>BasicBlockPass</em> is pretty like <em>FunctionPass</em>, but focusing on different level. So, RTFM ; p</p>

<h4 id="looppass">LoopPass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1LoopPass.html"><em>LoopPass</em></a> works on each loop inside functions. All <em>LoopPasses</em> are independ from each other, and when multiple loops are nested, the outer most loop is excuted last. To implement this Pass, we need to overwrite <em>runOnLoop</em> method.</p>

<h4 id="regionpass">RegionPass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1RegionPass.html"><em>RegionPass</em></a> visit the basic blocks that not in loops in each function. This Pass is not so widely used, so I will not give a simple demo on this Pass.</p>

<h4 id="machinefunctionpass">MachineFunctionPass</h4>

<p><a href="http://llvm.org/doxygen/classllvm_1_1MachineFunctionPass.html"><em>MachineFunctionPass</em></a> is a machine dependent Pass. This Pass is a part of code generator in LLVM framework. Hence, this Pass cannot be run using <em>opt</em> command.</p>

<h3 id="conclusion">Conclusion</h3>

<p>This post only gives an overview on LLVM Passes, and gives some simple&amp; easy examples. For some details, I would like to talk about them in series articles. If you find any mistakes, please contact me :)</p>

<p>Code source for this article is available on <a href="https://github.com/Higuoxing/blog-source/tree/master/llvm-passes">GitHub</a></p>

<h3 id="further-reading">Further Reading</h3>

<ul>
<li><a href="http://www.aosabook.org/en/llvm.html">LLVM - The Architecture of Open Source Applications</a> &ndash; Chris Lattner</li>
<li><a href="http://llvm.org/docs/WritingAnLLVMPass.html">Writing an LLVM Pass</a> &ndash; LLVM Docs</li>
<li><a href="http://laure.gonnord.org/pro/research/ER03_2015/lab3_intro.pdf">Writing an LLVM Pass</a> &ndash; Department of Computer Science - Universidade Federal de Minas Gerais</li>
<li><a href="http://www.cs.cornell.edu/~asampson/blog/llvm.html">LLVM for Grad Students</a> &ndash; Adrian Sampson</li>
<li><a href="http://www.grosser.es/publications/grosser-2012--LLVM-and-Polly-Tutorial--Indian-Institute-of-Science.pdf">LLVM-and-Polly-Tutorial</a> &ndash; Though a Polly related slides, it still introducing lots of background knowledges</li>
</ul>

</main>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "higuoxing" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  <footer>
  <script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  
  <hr/>
  &copy;  2017 &ndash; 2018 <a href="https://higuoxing.com/">Higuoxing</a> | Powered by <a href="https://github.com/gohugoio/hugo">Hugo</a> | Theme: <a href="https://github.com/yihui/hugo-xmin">Xmin</a>
  
  </footer>
  </body>
</html>

