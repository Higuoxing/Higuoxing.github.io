<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Value Categories in C&#43;&#43; | Somewhere</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="shortcut icon" href="/img/favicon.png" type="image/x-icon" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">$Home</a></li>
      
      <li><a href="/archives/">Archives</a></li>
      
      <li><a href="/links/">Links</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Value Categories in C++</span></h1>

<h2 class="date">2018/09/16</h2>
</div>

<main>
<h3 id="introduction">Introduction</h3>

<p>In C++11, with the introducing of move semantics, C++ extended its value categories. Hence, it’s possibly not a good idea to roughly identify expression’s value categories to be <em>lvalue</em> and <em>rvalue</em>. This post is to dump some notes about “Value Category” of expressions in C++, together with some interesting history. Just some basic knowledge about C++ is required.</p>

<h3 id="expressions">Expressions</h3>

<p><em>An expression is a sequence of operators and their operands, that specifies a computation.</em>
(&ndash; from <a href="https://en.cppreference.com/w/cpp/language/expressions">cppreference</a>)
A program is just a combination of expressions, for example</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0b0;font-weight:bold">int</span> a <span style="color:#666">=</span> <span style="color:#666">1</span>;
<span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> <span style="color:#666">2</span>;
a <span style="color:#666">=</span> a <span style="color:#666">+</span> b;
printf(<span style="color:#b44">&#34;%d&#34;</span>, a);
</code></pre></div>
<p>We assign <em>literal 1</em> to <em>a</em>, then assign <em>literal 2</em> to <em>b</em>, then assign <em>a+b</em> to <em>a</em>, and then print the result of <em>a</em>. (Note: all steps are expressions. function <em>printf</em> is an expression as well, which returns the length of the string. In this case, it will return <em>1</em>, the length of <em>“3”</em>, but we did not assign it to anything).</p>

<h3 id="history">History</h3>

<p>Usually, we characterized an expression in two dimensions, type and value category. In early days, the taxonomy of value categories was first introduced in CPL (Combined Programming Language, the ancestor of BCPL, Basic Combined Programming Language). In CPL, expressions can be evaluated in two modes, known as <em>left-hand</em> (LH) and <em>right-hand</em> (RH) modes. However, only certain kinds of expression are meaningful in LH mode. Take this factorial computing function for example:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CPL" data-lang="CPL">function Fact2[x] = result of
  § real f  = 1
    until x = 0 do
      f, x := xf, x -- 1
    result := f §</code></pre></div>
<p>The CPL looks like some kinds of pseudocode, so here, we will not give too much details about its grammars. In the expression f, x := xf, x &ndash; 1 (xf is similar to what we do <em>xf</em> in C/C++), the assignment command <em>:=</em> is to tell the computing system to compute the RH value obtained from right-hand of the symbol and then assign the RH value to the address (LH value) that obtained from left-hand of the assignment symbol (<em>:=</em>). Hence, this is the original version taxonomy of value categories and that is what generally in our minds about <em>lvalue</em> and <em>rvalue</em>. For further features about CPL, I recommend <a href="https://pdfs.semanticscholar.org/7241/5562aa3f8005fb82a4e9b1f34b8eb268dad6.pdf">“The main features of CPL”</a>.</p>

<p>Then, in C, Dennis Ritchie (or dmr, father of C programming language and co-author of Unix system) characterized expressions into <em>lvalues</em> and others. <em>lvalue</em> is a “locator value”. This is very similar to the taxonomy in CPL.</p>

<p>In early C++, Bjarne Stroustrup did the same as C, but restored the term “rvalue” for “non-lvalue expressions”. Besides, in C++98, functions are made into <em>lvalues</em>, references could be bound to <em>lvalues</em>, and only reference to const value could be bound to rvalue (we do not need to think too much about reference to const that bound to rvalue, we will come to it later). A small example:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0b0;font-weight:bold">int</span> global_val <span style="color:#666">=</span> <span style="color:#666">0</span>;

<span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&amp;</span> func() {
  <span style="color:#a2f;font-weight:bold">return</span> global_val;
}

<span style="color:#0b0;font-weight:bold">int</span> main() {
  func() <span style="color:#666">=</span> <span style="color:#666">2</span>;
  <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
}
</code></pre></div>
<p>In this example, function <em>func</em> return the reference of <em>global_val</em> which is a lvalue (function that returns a lvalue reference is a lvalue), and we could assign <em>literal 2</em> to the reference returned by <em>func</em>.</p>

<p>In C++11, just like what we mentioned before, expressions have two properties: has identity and “can be moved from”. If an expression “has identity”, we could tell if two copies are identical. For example, <em>int a = 2;</em> <em>int b = 2;</em> we know that a and b are identical, because they are two variables and have different addresses in memory, while values of literals like <em>(char) ‘a’</em>, <em>(int) 12</em> “do not have identity”. The property “can be moved from” denotes whether the resource managed by this object can be transferred to another object. This is related to move semantics in C++11, which we will discuss in next section. Based on these two independent properties, expressions could be categorized into four groups, See Bjarne Stroustrup post <a href="http://www.stroustrup.com/terminology.pdf">“New” Value Terminology</a></p>

<ul>
<li>im &ndash; <em>“has identity”</em> and <em>“can be moved from”</em>, named to be <em>xvalue</em></li>
<li>iM &ndash; <em>“has identity”</em> and <em>“cannot be moved from”</em>, named to be <em>lvalue</em></li>
<li>Im &ndash; <em>“do not have identity”</em> and <em>“can be moved from”</em>, named to be <em>prvalue</em></li>
<li>IM &ndash; <em>“do not have identity”</em> and <em>“cannot be moved from”</em>, not existed</li>
</ul>

<p>However, the last one is not existed in C++ or most of programming languages. Hence, the relationships between im, iM, Im can be described in one diagram:</p>

<pre><code>(iM)    (im)    (Im)       (lvalue)  (xvalue)  (prvalue)
   \   /    \   /      or      \      /    \     /
    (i)      (m)              (glvalue)    (rvalue)
</code></pre>

<p><em>Note</em>: <em>glvalue</em> means generalized <em>lvalue</em>, <em>xvalue</em> means <em>eXpiring value</em> and <em>prvalue</em> means <em>pure rvalue</em>.</p>

<p>Here, we just give the names of value categories in C++11, for their details, we have to give them after explaining the move semantics in next section.</p>

<h3 id="move-semantics-rvalue-reference">Move Semantics&amp; RValue Reference</h3>

<p>Move Semantics was introduced in C++11, and was designed to lower the cost when transferring the ownership of resources. For example, we have a big object who owns huge external resources. So, if we want to transferring the ownership of resources, in C++, we could simply make the new owner’s resource pointer point to the same memory area, rather than make a copy of the resource and then delete the original one.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#080">#include</span> <span style="color:#080">&lt;iostream&gt;</span><span style="color:#080">
</span><span style="color:#080"></span>
<span style="color:#a2f;font-weight:bold">class</span><span style=""> </span><span style="color:#00f">BigObject</span> {
<span style="color:#a2f;font-weight:bold">private</span><span style="color:#666">:</span>
  <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#666">*</span>_resource;
  size_t _size;
<span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
  BigObject(size_t size)
    <span style="color:#666">:</span> _size(size), _resource(<span style="color:#a2f;font-weight:bold">new</span> <span style="color:#0b0;font-weight:bold">int</span>[size]) {
    printf(<span style="color:#b44">&#34;create an object with %zu resources</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>, _size);
  }

  BigObject(<span style="color:#a2f;font-weight:bold">const</span> BigObject<span style="color:#666">&amp;</span> another)
    <span style="color:#666">:</span> _size(another._size), _resource(<span style="color:#a2f;font-weight:bold">new</span> <span style="color:#0b0;font-weight:bold">int</span>[another._size]) {
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> another._size; <span style="color:#666">++</span> i)
      _resource[i] <span style="color:#666">=</span> another._resource[i];
    printf(<span style="color:#b44">&#34;copy an object with %zu resources</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>, _size);
  }

  <span style="color:#666">~</span> BigObject() {
    <span style="color:#a2f;font-weight:bold">delete</span> [] _resource;
    printf(<span style="color:#b44">&#34;destory an object with %zu resources</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>, _size);
  }

};

BigObject <span style="color:#00a000">createBigObject</span>(size_t size) {
  BigObject tmp(size);
  <span style="color:#a2f;font-weight:bold">return</span> tmp;
}

<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">main</span>() {
  BigObject bigObj(createBigObject(<span style="color:#666">100</span>));
  <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
}
</code></pre></div>
<p>In this example, we have created a <em>BigObject</em> and it has a dynamic int array. Note: most of modern compilers will inspect our return values, and will do some kinds of optimizations called <em>RVO</em> &ndash; (Return Value Optimization) and <em>NRVO</em> &ndash; (Named Return Value Optimization), this could help prevent constructing useless temporary variables. In this case, <em>BigObject tmp</em> is a temporary variable returned by function <em>createBigObject()</em>, and tmp was created by <em>BigObject()</em>. So, if we compile the code simply with</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">clang++ -std<span style="color:#666">=</span>c++11 main.cc <span style="color:#666">&amp;&amp;</span> ./a.out</code></pre></div>
<p>compiler will just pass the original data to <em>bigObj</em> and then we could get the printed messages:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">create an object with <span style="color:#666">100</span> resources
destory an object with <span style="color:#666">100</span> resources</code></pre></div>
<p>Adding the flag “-fno-elide-constructors” could tell the compiler not to perform the optimizations. Here, we will not dig too much about <em>RVO</em> or <em>NRVO</em>.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">clang++ -std<span style="color:#666">=</span>c++11 -fno-elide-constructors main.cc <span style="color:#666">&amp;&amp;</span> ./a.out</code></pre></div>
<p>then we will get</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">create an object with <span style="color:#666">100</span> resources
copy an object with <span style="color:#666">100</span> resources
destory an object with <span style="color:#666">100</span> resources
copy an object with <span style="color:#666">100</span> resources
destory an object with <span style="color:#666">100</span> resources
destory an object with <span style="color:#666">100</span> resources</code></pre></div>
<p>As you see, our data was copied two times and it is not difficult to understand. <em>BigObject tmp(100);</em> created the original data, then original data was copied to <em>tmp</em>, and then <em>tmp</em> was copied to <em>bigObj</em>. Because function <em>createBigObject</em> returned rvalue and when the code run out of the scope, it will disappear, and what we could do is to copy it again. How to solve this problem? One simple solution is to return the instance of object by pointer. However, in C++0x, it provides us a new feature called rvalue reference. It means we could pass a rvalue reference out of its scope. <em>Note</em>: <em>BigObject&amp;&amp;</em> means <em>rvalue reference</em> not reference to reference</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BigObject(BigObject<span style="color:#666">&amp;&amp;</span> another) <span style="color:#080;font-style:italic">// move constructor
</span><span style="color:#080;font-style:italic"></span>  <span style="color:#666">:</span> _size(another._size), _resource(<span style="color:#a2f;font-weight:bold">new</span> <span style="color:#0b0;font-weight:bold">int</span>[another._size]) {
  _resource <span style="color:#666">=</span> another._resource;
  another._resource <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">nullptr</span>;
  another._size <span style="color:#666">=</span> <span style="color:#666">0</span>;
  printf(<span style="color:#b44">&#34;move an object with %zu resources</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>, _size);
}
</code></pre></div>
<p>With this, our compiler will automatically using this <em>move constructor</em> to pass the ownership without copying the resources again and again. This will print:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">create an object with <span style="color:#666">100</span> resources
move an object with <span style="color:#666">100</span> resources
destory an object with <span style="color:#666">0</span> resources
move an object with <span style="color:#666">100</span> resources
destory an object with <span style="color:#666">0</span> resources
destory an object with <span style="color:#666">100</span> resources</code></pre></div>
<p>This is a simple example of how <em>moving semantics</em> help improve the performance of codes. Actually, the property <em>“can be moved from”</em> is derived from this. C++ STL provides us a useful function called <em>std::move()</em>, which could help us transfer ownership efficiently.
<em>Note</em>: the transfering ownership process is not happening when <em>std::move()</em> is applied, it is happening when <em>move constructor</em> is called. <em>std::move()</em> is defined as</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#a2f;font-weight:bold">template</span> <span style="color:#666">&lt;</span><span style="color:#a2f;font-weight:bold">typename</span> T<span style="color:#666">&gt;</span>
<span style="color:#a2f;font-weight:bold">decltype</span>(<span style="color:#a2f;font-weight:bold">auto</span>) move (T<span style="color:#666">&amp;&amp;</span> param) {
  <span style="color:#a2f;font-weight:bold">using</span> ReturnType <span style="color:#666">=</span> remove_reference_t<span style="color:#666">&lt;</span>T<span style="color:#666">&gt;&amp;&amp;</span>;
  <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">static_cast</span><span style="color:#666">&lt;</span>ReturnType<span style="color:#666">&gt;</span> (param);
}
</code></pre></div>
<p><em>std::move()</em> is to help casting <em>lvalue</em> to <em>xvalue</em></p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">string a0 <span style="color:#666">=</span> <span style="color:#b44">&#34;hello, world&#34;</span>;
string a1 <span style="color:#666">=</span> std<span style="color:#666">::</span>move(a0);
</code></pre></div>
<p>Now, we could discuss the taxonomy.</p>

<ul>
<li><p><em>lvalue</em> &ndash; “have identity”, “cannot be moved from”. Because if we want to modify or use a lvalue later, the ownership of it cannot be stolen or moved from, this will cause catastrophe.</p>

<p>e.g.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0b0;font-weight:bold">int</span> a <span style="color:#666">=</span> <span style="color:#666">1</span>; 
<span style="color:#080;font-style:italic">/* a is a lvalue, because we may reference it later */</span>
<span style="color:#666">++</span> a; <span style="color:#666">--</span> a; 
<span style="color:#080;font-style:italic">/* ++ a or -- a are lvalues, because a will immediately increase/decrease by 1, and we may use the value of a in the context later. */</span>
<span style="color:#b44">&#34;hello&#34;</span>;
<span style="color:#080;font-style:italic">/* Yes, literal string is a lvalue, because it cannot be moved from, and it is array type, two strings &#34;hello&#34;, &#34;hello&#34; may refer to two different memory area */</span>
</code></pre></div>
<ul>
<li><em>prvalue</em> &ndash; “do not have identity”, “can be moved from”. an expression whose evaluation either computes the value of the operand of an operator, or initializes an object or a bit-field.</li>
</ul>

<p>e.g.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">a <span style="color:#666">+</span> b;
<span style="color:#080;font-style:italic">/* expression that computing the value of a + b and left no object */</span>
<span style="color:#666">43</span>;
<span style="color:#080;font-style:italic">/* int literal */</span>
<span style="color:#a2f">true</span>;
<span style="color:#080;font-style:italic">/* bool literal */</span>
</code></pre></div></li>

<li><p><em>xvalue</em> &ndash; “has identity”, “can be moved from”. a glvalue that denotes an object or bit-field whose resources can be reused</p>

<p>e.g.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#666">::</span>move(x);
<span style="color:#080;font-style:italic">/* will be expired later */</span>
</code></pre></div>
<ul>
<li><em>glvalue</em> &ndash; “has identity”. an expression whose evaluation determines the identity of an object, bit-field, or function.</li>
<li><em>rvalue</em> &ndash; “can be moved from”. Could appear on the righ-hand side of an assignment expression. So-called, historically</li>
</ul>

<h3 id="conclusion">Conclusion</h3>

<p>All these value categories are designed to help us construct high performance and robust codes, help compiler whether, when and where to perform optimizations. Last thing to remember, moving action is not happening when std::move is called but <em>move constructor</em> is called.</p>

<h3 id="further-reading">Further Reading</h3>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf">A Taxonomy of Expression ValueCategories</a></li>
<li><a href="http://www.stroustrup.com/terminology.pdf">&ldquo;New&rdquo; Value Terminology</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en">RVO V.S. std::move</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/value_category">Cpp reference - Value Category</a></li>
</ul></li>
</ul>
</main>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "higuoxing" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  <footer>
  <script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  
  <hr/>
  &copy;  2017 &ndash; 2019 <a href="https://vgxbj.github.io/">Xing GUO</a> | Powered by <a href="https://github.com/gohugoio/hugo">Hugo</a> | Theme: <a href="https://github.com/yihui/hugo-xmin">Xmin</a>
  
  </footer>
  </body>
</html>

